<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>File | Five Dimensions(5D) | writing for fun</title>

  
  <meta name="author" content="5 D">
  

  
  <meta name="description" content="five dimensions">
  

  
  
  <meta name="keywords" content="Android 翻译">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="File"/>

  <meta property="og:site_name" content="Five Dimensions(5D)"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/images/5d.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Five Dimensions(5D)" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Five Dimensions(5D)</a>
    </h1>
    <p class="site-description">writing for fun</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>File</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/05/07/一/译/file/" rel="bookmark">
        <time class="entry-date published" datetime="2017-05-07T04:23:43.000Z">
          2017-05-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h3 id="Class-Overview-类概述"><a href="#Class-Overview-类概述" class="headerlink" title="Class Overview (类概述)"></a>Class Overview (类概述)</h3><p>一个由路径名确定文件系统实体的“抽象”表示。这个路径名可能是绝对路径（相对于文件系统的根目录）或是相对于程序运行的当前路径。</p>
<p>文件所引用的实际文件可能存在也可能不存在。它也可能是忽略文件的名称，只是一个目录或是一个非常规的文件。</p>
<p>这个类提供了有限的函数来获取或设置文件的权限，文件的类型，文件的最后修改时间。</p>
<p>当 Android 字符串转换为 UTF-8 字节序列时，发送文件到操作系统，字节序列会被系统返回（从各种列表方法）按照 UTF-8 转换为字符串。</p>
<span id="more"></span>

<h3 id="Fields（字段）"><a href="#Fields（字段）" class="headerlink" title="Fields（字段）"></a>Fields（字段）</h3><p>public static final String  pathSeparator  系统相关的字符串，用于在搜索路径中分离组件（“：”）。</p>
<p>public static final char pathSeparatorChar  系统相关的字符，用于在搜索路径中分离组件。（’:’）。这个是用来把 PATH 环境变量和类路径（classpath）系统属性分割成要搜索的目录列表。</p>
<p>public static final String separator  系统相关的字符串用于分割文件名（“&#x2F;”）。</p>
<p>public static final char separatorChar 系统相关的字符，用于分割文件名（“&#x2F;”）。使用这个（而不是硬编码）有助于其他系统的可移植性。</p>
<p>该字段从系统属性“file.separator”初始化。以后更改此属性不会对该字段或该类有影响。</p>
<h3 id="Public-Construcorts-公共的构造方法"><a href="#Public-Construcorts-公共的构造方法" class="headerlink" title="Public Construcorts (公共的构造方法)"></a>Public Construcorts (公共的构造方法)</h3><p><strong>public File(File dir,String name)</strong></p>
<p>通过指定的目录和名字创建一个新的文件。</p>
<p><em>参数：</em></p>
<p>dir		文件存储的目录</p>
<p>name 	该文件的名字</p>
<p><em>异常：</em></p>
<p>空指针	当 name 为空时</p>
<p><strong>public File (String path)</strong></p>
<p>通过指定的路径创建一个文件</p>
<p><em>参数：</em></p>
<p>path	作文件的路径</p>
<p><em>异常：</em></p>
<p>空指针	当 path 为空时</p>
<p><strong>public File(String path,String name)</strong></p>
<p>通过指定的目录路径和文件名称创建一个新的文件，在两者之间放置一个路径分割符。</p>
<p><em>参数：</em></p>
<p>dirPath		储文件的目录的路径。</p>
<p>name 		文件的名称。</p>
<p><em>异常：</em></p>
<p>空指针 		当 name 为空时。</p>
<p><strong>public File (URI uri)</strong></p>
<p>通过指定的 URI 路径创建新的文件。uri 需要是具有文件方案和非空路径组件的绝对和分层统一资源标识符，但具有未定义的权限，查询或片段组件。</p>
<p><em>参数：</em></p>
<p>uri		被用来创建文件的统一资源标识符。</p>
<p><em>异常：</em></p>
<p>空指针	当 uri 为空时。</p>
<p>非法参数 当 uri 不符合上述条件时。</p>
<p>###Public Methods (公共方法)</p>
<p><strong>public boolean canExecute()</strong></p>
<p>测试此程序是否允许执行此文件。这是最好的努力结果，确定的唯一方法就是实际尝试操作。</p>
<p><em>返回值:</em></p>
<p>如果能执行返回 true ，否则返回 false。</p>
<p><strong>public boolean canRead()</strong></p>
<p>测试该文件在当前环境是否可读。</p>
<p><em>返回值：</em></p>
<p>如果可读返回 true ，否则返回 false。</p>
<p><strong>public boolean canWrite()</strong></p>
<p>测试该文件在当前环境是否可写。</p>
<p><em>返回值:</em></p>
<p>如果可写返回 true，否则返回 false。</p>
<p><strong>public int compareTo(File another)</strong></p>
<p>返回此文件和另一文件的路径的相对排序顺序。排序依赖于平台。</p>
<p><em>参数：</em></p>
<p>another 	与该文件比较的文件。</p>
<p><em>返回值：</em></p>
<p>通过比较两个路径确定的一个 int 值。可比较的值在 Comparable 接口中描述。</p>
<p><strong>public boolean createNewFile()</strong></p>
<p>根据文件中存储的路径信息在文件系统上创建一个新的空文件。如果创建一个文件返回 true，如果文件已经存在返回 false。注意，即使这个文件不是一个文件（因为它是一个目录）也会返回 false。</p>
<p>这个方法通常不是有用的。如果创建一个临时文件的话使用 createTempFile（String ，String）方法代替。如果是读&#x2F;写文件的话，用 FileInputStream，FileOutputStream，或是 RandmAccessFile，所有的这些都能创建文件。</p>
<p>注意，如果这个文件已经存在这个方法是不会拋出 IO 异常的，即使它不是一个常规的文件。用户应该始终检查返回值，此外还应调用 isFile()方法。</p>
<p><em>返回值：</em></p>
<p>如果文件被创建返回 ture ，如果文件已经存在返回 false。</p>
<p><em>异常：</em></p>
<p>IO 异常 		如果不能创建文件。</p>
<p><strong>public static File createTempFile(String prefix,String suffix,File directory)</strong></p>
<p>在指定的目录创建一个文件，用指定的前缀和后缀作为文件名的一部分。如果后缀为空的话，则使用 .tmp。</p>
<p>注意，这个方法不会调用 deleteOnExit（）方法，在手动调用该方法之前，请参阅该方法的文档。</p>
<p><em>参数：</em></p>
<p>prefix 		空文件名的前缀</p>
<p>suffix 		空文件名的后缀</p>
<p>directory   要写入临时文件的位置，如果为 null 的话就是默认位置，这个默认位置是来自于<br>           “java.io.tmpdir” 系统属性。可能需要将此属性设置为现有的可写目录，以使此方法<br>            正常工作。</p>
<p><em>返回值：</em></p>
<p>临时文件</p>
<p><em>异常：</em></p>
<p>参数非法 		当前缀的长度小 3。</p>
<p>IO 异常 		写入文件是出错。</p>
<p><strong>public static File createTempFile(String prefix,String suffix)</strong></p>
<p>创建一个临时的空文件，使用指定的前缀和后缀作为文件名的一部分。如果后缀为空的话，则使用 .tmp。当调用 createTempFile(String,String,File)方法，第三个参数为空时，使用该方法是方便的。</p>
<p><em>参数：</em></p>
<p>prefix  	文件名的前缀</p>
<p>suffix 		文件名的后缀</p>
<p><em>返回值：</em></p>
<p>临时文件</p>
<p><em>异常：</em></p>
<p>IO 异常 		写入文件出错</p>
<p><strong>public boolean delete()</strong></p>
<p>删除这个文件。目录是空的才能删除这个文件。</p>
<p>注意，删除失败时这个方法不会拋出 IO 异常，用户必须要检查返回值。</p>
<p><em>返回值：</em></p>
<p>如果文件被删除返回 true，否则返回 false。</p>
<p><strong>public void deleteOnExit()</strong></p>
<p>当 VM 正常终止时，文件自动删除。</p>
<p>注意，在 Android 中，生命周期不包括 VM 的终止，因此调用这个方法不能确定文件是否被删除。所以你应该使用以下最有效的方法：</p>
<ul>
<li>使用 finally 语句手动调用 delete（）方法</li>
<li>把文件做为一个集合，在程序的生命周期的合适位置进行处理</li>
<li>当任意一个reader 或 writer 打开它时，就使用 Unix 的策略删除。没有新的readers&#x2F;writers 能够访问该文件，但是所有现有的 readers&#x2F;writers 将仍然可以访问，直到最后一个文件关闭。</li>
</ul>
<p><strong>public boolean equals(Object obj)</strong></p>
<p>比较 obj 与这个文件，如果使用特定的路径比较他们代表同一个对象就返回 true。</p>
<p><em>返回值：</em></p>
<p>当 obj 与当前的 file 代表的是同一个对象返回 true 否则返回 false。</p>
<p><strong>public boolean exists()</strong></p>
<p>返回一个布尔值表示这个文件是否能在底层文件系统找到。</p>
<p><em>返回值：</em></p>
<p>当这文件存在时返回 true 否则返回 false。</p>
<p><strong>public File getAbsoluteFile()</strong></p>
<p>返回一个使用该文件的绝对路径创建的新的文件。等同于 new File（this.getAbsoluPath())。</p>
<p><strong>public String getAbsolutePath()</strong></p>
<p>返回该文件的绝对路径。绝对路径是开始于文件系统的根目录。在 Android 中只有一个根目录：&#x2F;</p>
<p>绝对路径的一个常用方法是将路径作为命令行参数传递给进程，要移除相对路径所隐藏的要求，该子目录必须与其父目录有相同的工作目录。</p>
<p><strong>public File getCanonicalFile()</strong></p>
<p>返回用该文件的规范路径创建的新的文件。等同于 new File（this.getCanonicalPath())。</p>
<p><em>返回值:</em></p>
<p>用该文件的规范路径创建的新的文件。</p>
<p><em>异常：</em></p>
<p>IO 异常 		发生 I&#x2F;O 错误时。</p>
<p><strong>public String getCanonicalPath()</strong></p>
<p>返回该文件的规范路径。绝对路径是从文件系统的根开始的。规范路径是具有符号链接和引用 “.” 或 “..” 的绝对路径，如果路径元素不存在（或不可搜索），则将规范化解释为文本操作之间存在冲突（“a&#x2F;..&#x2F;b” 的位置是 “b”，即使 “a” 不存在）。</p>
<p>大多数的用户应该使用 getAbsolutePath()代替它。规范的路径需要大量的计算，而且一般都是没用的。规范路径最常见的用法是，通过比较规范路径测试两个路径是否指向同一个文件。</p>
<p>使用规范路径可能是有害的，因为规范化删除了符号链接。假设一个符号链接是有原因的，这是明智的，因为链接可能需要改变。规范除去了这个间接层。好的代码一般避免缓存规范化路径。</p>
<p><em>返回值：</em></p>
<p>文件的规范化路径</p>
<p><em>异常：</em></p>
<p>IO 异常 		当 IO 出现异常时。</p>
<p><strong>public long getFreeSpace()</strong></p>
<p>返回包含此路径的分区上的空空余字节数。返回 0 当路径不存在时。</p>
<p>注意，这可能是一个乐观的高估，不应被视为一个保证应用程序实际上可以写这么多字节。</p>
<p><strong>public String getName()</strong></p>
<p>返回由该文件表示的文件或目录的名称。</p>
<p><em>返回值：</em></p>
<p>该文件的名称或是一个空的字符串当该文件的路径没有名称部分。</p>
<p><strong>public String getParent()</strong></p>
<p>返回该文件的父文件的路径名称。</p>
<p><em>返回值：</em></p>
<p>该文件的父文件的路径名称或 null。</p>
<p><strong>public File getParentFile()</strong></p>
<p>返回由该文件的父文件的路径名称创建的一个新文件。这个路径直到但不包括最后一个名称。当该文件没有父文件时返回 null。</p>
<p><em>返回值：</em></p>
<p>由该文件的父文件的路径名称创建的新文件，或是 null。</p>
<p><strong>public String getPath()</strong></p>
<p>返回文件的路径。</p>
<p><strong>public long getTotalSpace()</strong></p>
<p>返回包含此路径的分区上的全部字节数。返回 0 如果文件不存在。</p>
<p><strong>public long getUsableSpace()</strong></p>
<p>返回包含此路径的分区上的可用字节数。返回 0 当此路径不存在时。</p>
<p>注意，这可能是一个乐观的高估，不应被视为一个保证应用程序实际上可以写这么多字节。在 Android（或是其他以 Unix 为基础的系统），此方法返回非 root 用户的可用字节数，不管你是否实际运行为root，也不管用户应用了其他任何配额或其他限制。（getFreeSpace 方法返回的字节数可能包含 root 的部分。）</p>
<p><strong>public int hashCode()</strong></p>
<p>返回接收器一个整型的哈希值。任何两个相同的对象一定返回一样的哈希值。</p>
<p><em>返回值：</em></p>
<p>文件的哈希值。</p>
<p><strong>public boolean isAbsolute()</strong></p>
<p>指示该文件的路径名是否是绝对的。路径名是否是绝对跟平台相关。在 Android 中绝对路径名开始于 ‘&#x2F;‘ 字符。</p>
<p><em>返回值：</em></p>
<p>如果该文件的路径名是绝对的返回 true 否则返回 false。</p>
<p><strong>public boolean isDirectory()</strong></p>
<p>指示该文件在文件系统上是否是一个目录。</p>
<p><em>返回值：</em></p>
<p>如果该文件是一个目录返回 true 否则返回 false。</p>
<p><strong>public boolean File()</strong></p>
<p>指示该文件在文件系统上是否是一个文件。</p>
<p><em>返回值:</em>*</p>
<p>如果是文件返回 true 否则返回 false。</p>
<p><strong>public boolean isHidden()</strong></p>
<p>指示该文件是否是一个由操作系统定义的隐藏文件。隐藏这个概念是由系统决定的。在 Unix 系统中，当文件名是以 “.” 开头的就被看作是隐藏的文件。对于 Windows 系统，在文件系统中有一个明确的标记来记录隐藏文件 。</p>
<p><em>返回值：</em></p>
<p>如果是隐藏文件返回 true 否则返回 false。</p>
<p><strong>public long lastModifide()</strong></p>
<p>返回该文件最后修改的时间，精确到毫秒从 1970 年 1 月 1 日凌晨开始算起。如果文件不存在返回 0。</p>
<p><em>返回值：</em></p>
<p>文件最后的修改时间。</p>
<p><strong>public long length()</strong></p>
<p>返回文件的字节长度。文件不存在返回 0.如果是目录则结果是未定义。</p>
<p><em>返回值：</em></p>
<p>文件的字节数。</p>
<p><strong>public String[] list()</strong></p>
<p>返回由该文件代表的目录中的文件名的字符串数组。如果文件不是目录则返回 null。</p>
<p>进入 . 和 .. 代表的是当前目录的父目录，不会作为该数组的一部分返回。</p>
<p><em>返回值：</em></p>
<p>该文件里的文件名的数组或 null。</p>
<p><strong>public String[] list(FilenameFilter filter)</strong></p>
<p>返回由该文件代表的目录中的文件的数组。这个数组将通过 FilenameFilter 和作为字符串返回的具有匹配名称的文件的名称被过滤。如果该文件不是目录返回 null。如果 filter 是 null 的话则所有的文件都可以匹配。</p>
<p>进入 . 和 .. 代表的是当前目录的父目录，不会作为该数组的一部分返回。</p>
<p><em>参数：</em></p>
<p>filter 		匹配名称的筛选器，可以为 null。</p>
<p><em>返回值：</em></p>
<p>文件数组或 null。</p>
<p><strong>public File[] listFiles()</strong></p>
<p>返回由该文件代表的目录中的文件的数组。如果 file 不是目录则返回 null。如果该文件的路径是绝对路径，那么数组中的路径也是绝对路径，否则是相对路径。</p>
<p><em>返回值：</em></p>
<p>文件是数组或 null。</p>
<p><strong>public static File[] lsitRoots()</strong></p>
<p>返回文件系统的根。在 Android 或是其他 Unix 系统中，只有一个根 &#x2F;。</p>
<p><strong>public boolean mkdir()</strong></p>
<p>由该文件创建一个目录，假设它的父目录是存在的。如果想要创建不存在的父目录使用 mkdirs()。</p>
<p>注意，当出现错误时这个方法不会抛出异常。用户必须检查返回值。 注意，当目录存在时返回 false。如果在返回时想要知道该文件是否存在，使用（f.mkdir() || f.isDirectory()）或者忽略该方法的返回值直接调用 isDirectory().</p>
<p><em>返回值：</em></p>
<p>如果目录被创建返回 ture，如果发生错误或是目录已经存在返回 false。</p>
<p><strong>public boolean mkdirs()</strong></p>
<p>由该文件创建一个目录，并且创建所有必须但不存在的父目录。如果不想创建父目录使用 mkdir()。</p>
<p>注意，当出现错误时该方法不会抛出异常。用户必须要检查返回值。注意，如果当目录存在时返回 false。如果在返回时想知道目录是否存在，使用（f.mkdirs() || f.isDirctory()）或者忽略该方法的返回值，直接调用 isDirctory().</p>
<p><em>返回值：</em></p>
<p>如果目录被创建返回 ture，如果发生错误或是目录已经存在返回 false。</p>
<p><strong>pubic boolean renameTo(File newPath)</strong></p>
<p>以新路径重命名文件。当两个都是文件或都是目录时该操作才能生效。</p>
<p>经常会发生一些错误。 一些更容易发生的错误包括：</p>
<ul>
<li>在包含源和目标路径的目录上写入权限是必须的。</li>
<li>两个路径的父路径的查询权限是必须的。</li>
<li>两个路径都要在同一个挂载点上。在 Android 中，应用程序最有可能碰到这个限制，当试图在内部存储和 SD 卡之间复制时。</li>
</ul>
<p>注意，当发生错误时该方法不会抛出异常。用户必须检查返回值。</p>
<p><em>参数：</em></p>
<p>newPath 	新的路径</p>
<p><em>返回值：</em></p>
<p>成功时返回 true。</p>
<p><strong>public boolean setExecutable(boolean executable)</strong></p>
<p>等同于 setExecutable(executable,true).</p>
<p><strong>public boolean setExecutable(boolean executable,boolean ownerOnly)</strong></p>
<p>操作此文件指定的抽象路径的执行权限。</p>
<p>注意，当出现错误时该方法不会抛出异常，用户必须检查返回值。</p>
<p><em>参数：</em></p>
<p>executable 		为 true 时允许执行权限，否则不允许。<br>ownerOnly 		为 true 时只有自己有操作执行权限，否则就是所有人。如果底层系统不区分所有者和其他用户，则该操作将应用于每个人，而不考虑该值。</p>
<p><em>返回值：</em></p>
<p>当且仅当操作成功时返回 true。如果用户没有权限去更改该抽象路径的访问权限则操作失败。如果底层文件系统不支持执行权限或是 executable 的值为 false 时操作失败。</p>
<p><strong>public boolean setLastModified(long time)</strong></p>
<p>设置文件最后被修改的时间，精确到秒从 1970 年 1 月 1 日凌晨开始。</p>
<p>注意，出现错误时该方法不会抛出异常，用户必须检查返回值。</p>
<p><em>参数：</em></p>
<p>time 	文件最后被修改的时间。</p>
<p><em>返回值：</em></p>
<p>如果操作成功返回 true，否则返回 false。</p>
<p><em>异常：</em></p>
<p>参数非法异常 		当 time &lt; 0.</p>
<p><strong>public boolean setReadOnly()</strong></p>
<p>等同于 setWritable(false,fasle).</p>
<p><strong>public boolean setReadable(boolean raedable)</strong></p>
<p>等同于 setReadable(readable,ture).</p>
<p><strong>public boolean setReadable(boolean readable,boolean ownerOnly)</strong></p>
<p>操作此文件指定的抽象路径的读取权限。</p>
<p><em>参数：</em></p>
<p>readable 	为 true 时允许读的权限，否则不允许。<br>ownerOnly 	为 true 时仅自己可操作读的权限，否则是所有人。 如果底层系统不区分所有者和其他用户，则该操作将应用于每个人，而不考虑该值。</p>
<p>*<em>返回值：</em></p>
<p>当且仅当操作成功时返回 true。如果用户没有权限去更改该抽象路径的访问权限则操作失败。如果底层文件系统不支持执行权限或是 readable 的值为 false 时操作失败。</p>
<p><strong>public boolean setWritable(boolean write,boolean ownerOnly)</strong></p>
<p>操作此文件指定的抽象路径的写入权限。</p>
<p>*<em>参数：</em></p>
<p>writable 	为 ture 时允许写的权限，否则不允许。<br>ownerOnly 	为 true 时仅自己可操作写的权限，否则是所有人。 如果底层系统不区分所有者和其他用户，则该操作将应用于每个人，而不考虑该值。</p>
<p><em>返回值：</em></p>
<p>当且仅当操作成功时返回 true。如果用户没有权限去更改该抽象路径的访问权限则操作失败。</p>
<p><strong>public boolean setWritable(boolean writable)</strong></p>
<p>等同于 setWritable(writable,ture).</p>
<p><strong>public String toString()</strong></p>
<p>返回一个简洁的、可读的描述该文件的字符串。</p>
<p><em>返回值：</em></p>
<p>描述文件的可打印的值。</p>
<p><strong>public URI toURI()</strong></p>
<p>返回文件的统一资源标识符。这个 URI 是由系统决定的，不能在不同的操作&#x2F;文件系统之间转换。</p>
<p><em>返回值：</em></p>
<p>文件的 URI.</p>
<p><strong>public URL toURL()</strong></p>
<pre><code>在 API 19 中该方法已经被废弃了。
使用 toURI() 和 toURL() 去正确的避开非法字符。
</code></pre>
<p>返回文件的统一资源定位符。URL 是由系统决定的，不能在不同的操作&#x2F;文件系统之间转换。</p>
<p><em>返回值：</em></p>
<p>文件的 URL</p>
<p><em>异常：</em></p>
<p>MalformedURLException 		当路径不能被转换为 URL 时。</p>

      





    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/一本正经/">一本正经</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android-翻译/">Android 翻译</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 5 D
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>